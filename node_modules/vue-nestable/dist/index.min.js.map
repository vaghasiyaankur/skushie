{"version":3,"file":"index.min.js","sources":["../src/groups-observer.js","../src/nestable-helpers.js","../src/calls-hooks.js","../src/utils.js","../src/index.js"],"sourcesContent":["const store = {}\n\nexport default {\n  methods: {\n    registerNestable (nestable) {\n      const storeGroup = this._getByGroup(nestable.group)\n\n      storeGroup.onDragStartListeners.push(nestable.onDragStart)\n      storeGroup.onMouseEnterListeners.push(nestable.onMouseEnter)\n      storeGroup.onMouseMoveListeners.push(nestable.onMouseMove)\n    },\n\n    notifyDragStart (group, event, item) {\n      const storeGroup = this._getByGroup(group)\n\n      for (const listener of storeGroup.onDragStartListeners) {\n        listener(event, item)\n      }\n    },\n\n    notifyMouseEnter (group, event, eventList, item) {\n      const storeGroup = this._getByGroup(group)\n\n      for (const listener of storeGroup.onMouseEnterListeners) {\n        listener(event, eventList, item)\n      }\n    },\n\n    notifyMouseMove (group, event) {\n      const storeGroup = this._getByGroup(group)\n\n      for (const listener of storeGroup.onMouseMoveListeners) {\n        listener(event)\n      }\n    },\n\n    _getByGroup (group) {\n      // the group already exists, return the reference\n      if (store[group]) {\n        return store[group]\n      }\n\n      // otherwise create a new object for the group\n      store[group] = {\n        onDragStartListeners: [],\n        onMouseEnterListeners: [],\n        onMouseMoveListeners: [],\n        onDragStart: [],\n        dragItem: null\n      }\n\n      return store[group]\n    }\n  }\n}\n","export default {\n  methods: {\n    // ––––––––––––––––––––––––––––––––––––\n    // Getter methods\n    // ––––––––––––––––––––––––––––––––––––\n    getPathById (id, items = this.value) {\n      let path = []\n\n      items.every((item, i) => {\n        if (item[this.keyProp] === id) {\n          path.push(i)\n        } else if (item[this.childrenProp]) {\n          const childrenPath = this.getPathById(id, item[this.childrenProp])\n\n          if (childrenPath.length) {\n            path = path.concat(i).concat(childrenPath)\n          }\n        }\n\n        return path.length === 0\n      })\n\n      return path\n    },\n\n    getItemByPath (path, items = this.value) {\n      let item = null\n\n      path.forEach(index => {\n        const list = item && item[this.childrenProp] ? item[this.childrenProp] : items\n        item = list[index]\n      })\n\n      return item\n    },\n\n    getItemDepth (item) {\n      let level = 1\n\n      if (item[this.childrenProp] && item[this.childrenProp].length > 0) {\n        const childrenDepths = item[this.childrenProp].map(this.getItemDepth)\n        level += Math.max(...childrenDepths)\n      }\n\n      return level\n    },\n\n    getSplicePath (path, options = {}) {\n      const splicePath = {}\n      const numToRemove = options.numToRemove || 0\n      const itemsToInsert = options.itemsToInsert || []\n      const lastIndex = path.length - 1\n      let currentPath = splicePath\n\n      path.forEach((index, i) => {\n        if (i === lastIndex) {\n          currentPath.$splice = [[index, numToRemove, ...itemsToInsert]]\n        } else {\n          const nextPath = {}\n          currentPath[index] = { [options.childrenProp]: nextPath }\n          currentPath = nextPath\n        }\n      })\n\n      return splicePath\n    },\n\n    getRealNextPath (prevPath, nextPath) {\n      const ppLastIndex = prevPath.length - 1\n      const npLastIndex = nextPath.length - 1\n\n      if (prevPath.length < nextPath.length) {\n        // move into deep\n        let wasShifted = false\n\n        return nextPath.map((nextIndex, i) => {\n          if (wasShifted) {\n            return i === npLastIndex\n              ? nextIndex + 1\n              : nextIndex\n          }\n\n          if (typeof prevPath[i] !== 'number') {\n            return nextIndex\n          }\n\n          if (nextPath[i] > prevPath[i] && i === ppLastIndex) {\n            wasShifted = true\n            return nextIndex - 1\n          }\n\n          return nextIndex\n        })\n      } else if (prevPath.length === nextPath.length) {\n        // if move bottom + move to item with children => make it a first child instead of swap\n        if (nextPath[npLastIndex] > prevPath[npLastIndex]) {\n          const target = this.getItemByPath(nextPath)\n\n          if (target[this.childrenProp] && target[this.childrenProp].length && !this.isCollapsed(target)) {\n            return nextPath\n              .slice(0, -1)\n              .concat(nextPath[npLastIndex] - 1)\n              .concat(0)\n          }\n        }\n      }\n\n      return nextPath\n    }\n\n    // getItemOptions() {\n    //   const { renderItem, renderCollapseIcon, handler, childrenProp } = this.props;\n    //   const { dragItem } = this.state;\n\n    //   return {\n    //     dragItem,\n    //     childrenProp,\n    //     renderItem,\n    //     renderCollapseIcon,\n    //     handler,\n\n    //     onDragStart: this.onDragStart,\n    //     onMouseEnter: this.onMouseEnter,\n    //     isCollapsed: this.isCollapsed,\n    //     onToggleCollapse: this.onToggleCollapse\n    //   };\n    // }\n\n  }\n}\n","export default {\n  methods: {\n    hook (name, params) {\n      // If the hook has not been registered,\n      // we consider the hook as successful\n      if (!this.hooks[name]) return true\n\n      const result = this.hooks[name](params)\n\n      // If the hook does not return anything,\n      // we also consider it true\n      return result || result === undefined\n    }\n  }\n}\n","export const closest = (target, selector) => {\n  return target.closest(selector)\n}\n\nexport const getOffsetRect = (elem) => {\n  var box = elem.getBoundingClientRect()\n\n  return { top: Math.round(box.top), left: Math.round(box.left) }\n}\n\nexport const getTransformProps = (x, y) => {\n  return {\n    transform: 'translate(' + x + 'px, ' + y + 'px)'\n  }\n}\n\nexport const listWithChildren = (list, childrenProp) => {\n  return list.map(item => {\n    return {\n      ...item,\n      [childrenProp]: item[childrenProp]\n        ? listWithChildren(item[childrenProp], childrenProp)\n        : []\n    }\n  })\n}\n","import VueNestable from './VueNestable.vue'\nimport VueNestableHandle from './VueNestableHandle.vue'\n\n// export named components\nexport {\n  VueNestable,\n  VueNestableHandle\n}\n\n// export vue component installer\nexport default {\n  install: function (Vue, options) {\n    Vue.component('VueNestable', VueNestable)\n    Vue.component('VueNestableHandle', VueNestableHandle)\n  }\n}\n"],"names":["store","methods","registerNestable","nestable","storeGroup","this","_getByGroup","group","onDragStartListeners","push","onDragStart","onMouseEnterListeners","onMouseEnter","onMouseMoveListeners","onMouseMove","notifyDragStart","event","item","listener","notifyMouseEnter","eventList","notifyMouseMove","dragItem","getPathById","id","items","value","path","every","i","_this","keyProp","childrenProp","childrenPath","length","concat","getItemByPath","forEach","index","list","_this2","getItemDepth","level","childrenDepths","map","Math","max","getSplicePath","options","splicePath","numToRemove","itemsToInsert","lastIndex","currentPath","$splice","nextPath","getRealNextPath","prevPath","ppLastIndex","npLastIndex","wasShifted","nextIndex","target","isCollapsed","slice","hook","name","params","hooks","result","undefined","listWithChildren","selector","closest","transform","elem","box","getBoundingClientRect","top","round","left","install","Vue","component","VueNestable","VueNestableHandle"],"mappings":"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"}