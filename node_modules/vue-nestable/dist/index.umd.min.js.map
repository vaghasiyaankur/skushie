{"version":3,"file":"index.umd.min.js","sources":["../src/groups-observer.js","../node_modules/vue-runtime-helpers/dist/normalize-component.mjs","../src/NestableItem.vue","../src/nestable-helpers.js","../src/calls-hooks.js","../node_modules/immutability-helper/index.js","../src/utils.js","../src/index.js"],"sourcesContent":["const store = {}\n\nexport default {\n  methods: {\n    registerNestable (nestable) {\n      const storeGroup = this._getByGroup(nestable.group)\n\n      storeGroup.onDragStartListeners.push(nestable.onDragStart)\n      storeGroup.onMouseEnterListeners.push(nestable.onMouseEnter)\n      storeGroup.onMouseMoveListeners.push(nestable.onMouseMove)\n    },\n\n    notifyDragStart (group, event, item) {\n      const storeGroup = this._getByGroup(group)\n\n      for (const listener of storeGroup.onDragStartListeners) {\n        listener(event, item)\n      }\n    },\n\n    notifyMouseEnter (group, event, eventList, item) {\n      const storeGroup = this._getByGroup(group)\n\n      for (const listener of storeGroup.onMouseEnterListeners) {\n        listener(event, eventList, item)\n      }\n    },\n\n    notifyMouseMove (group, event) {\n      const storeGroup = this._getByGroup(group)\n\n      for (const listener of storeGroup.onMouseMoveListeners) {\n        listener(event)\n      }\n    },\n\n    _getByGroup (group) {\n      // the group already exists, return the reference\n      if (store[group]) {\n        return store[group]\n      }\n\n      // otherwise create a new object for the group\n      store[group] = {\n        onDragStartListeners: [],\n        onMouseEnterListeners: [],\n        onMouseMoveListeners: [],\n        onDragStart: [],\n        dragItem: null\n      }\n\n      return store[group]\n    }\n  }\n}\n","function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\nexport default normalizeComponent;\n//# sourceMappingURL=normalize-component.mjs.map\n","<template>\n  <li :class=\"itemClasses\">\n    <div\n      class=\"nestable-item-content\"\n      @mouseenter=\"onMouseEnter\"\n      @mouseleave=\"onMouseLeave\"\n      @mousemove=\"onMouseMove\"\n    >\n      <slot\n        :index=\"index\"\n        :item=\"item\"\n        :isChild=\"isChild\"\n      />\n    </div>\n\n    <ol\n      v-if=\"hasChildren\"\n      class=\"nestable-list\"\n    >\n      <template\n        v-for=\"(child, childIndex) in item[options.childrenProp]\"\n      >\n        <NestableItem\n          :key=\"child[keyProp]\"\n          :item=\"child\"\n          :index=\"childIndex\"\n          :options=\"options\"\n          :is-copy=\"isCopy\"\n          is-child\n        >\n          <!-- bind scoped slots to the netable-item component -->\n          <template\n            v-for=\"slot in Object.keys($scopedSlots)\"\n            :slot=\"slot\"\n            slot-scope=\"scope\"\n          >\n            <slot\n              :name=\"slot\"\n              v-bind=\"scope\"\n            />\n          </template>\n        </NestableItem>\n      </template>\n    </ol>\n  </li>\n</template>\n\n<script type=\"text/babel\">\nimport groupsObserver from './groups-observer.js'\n\nexport default {\n  name: 'NestableItem',\n\n  mixins: [groupsObserver],\n\n  props: {\n    item: {\n      type: Object,\n      required: true,\n      default: () => ({})\n    },\n    index: {\n      type: Number,\n      required: false,\n      default: null\n    },\n    isChild: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    isCopy: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    options: {\n      type: Object,\n      required: true,\n      default: () => ({})\n    }\n  },\n\n  inject: ['listId', 'group', 'keyProp'],\n\n  data () {\n    return {\n      breakPoint: null,\n      moveDown: false\n    }\n  },\n\n  computed: {\n    isDragging () {\n      const dragItem = this.options.dragItem\n      return !this.isCopy && dragItem && dragItem[this.options.keyProp] === this.item[this.options.keyProp]\n    },\n\n    hasChildren () {\n      return this.item[this.options.childrenProp] && this.item[this.options.childrenProp].length > 0\n    },\n\n    hasHandle () {\n      return !!this.$scopedSlots.handler\n    },\n\n    normalizedClassProp () {\n      const classProp = this.item[this.options.classProp]\n\n      // if the classprop is not set, return an empty array\n      if (!classProp) return []\n\n      if (Array.isArray(classProp)) {\n        return classProp\n      } else if (typeof a === 'object') {\n        return [classProp]\n      } else {\n        // String value\n        return [classProp]\n      }\n    },\n\n    itemClasses () {\n      const isDragging = this.isDragging ? ['is-dragging'] : []\n\n      return [\n        `nestable-item${this.isCopy ? '-copy' : ''}`,\n        `nestable-item${this.isCopy ? '-copy' : ''}-${this.item[this.options.keyProp]}`,\n        ...isDragging,\n        ...this.normalizedClassProp\n      ]\n    }\n  },\n\n  methods: {\n    onMouseEnter (event) {\n      if (!this.options.dragItem) return\n\n      // if we don't know the direction the mouse is moving,\n      // we can not calculate the offset at which we should trigger a swap\n      // we we fallback to the old behavior\n      if (!event.movementY) {\n        return this.sendNotification(event)\n      }\n\n      // when the mouse enters the item we save the size of this item\n      // is is to improve performance, so we do not recalculate the size on every move\n      this.moveDown = event.movementY > 0\n\n      this.breakPoint = event.target.getBoundingClientRect().height / 2\n    },\n    onMouseLeave () {\n      this.breakPoint = null\n    },\n    onMouseMove (event) {\n      // if we are not in a drag operation, we can discard the input\n      if (!this.breakPoint) return\n\n      // calculate how much the mouse is away from the center\n      const delta = event.offsetY - this.breakPoint\n\n      // if we have not reached the breakpoint, we can abort here\n      if (this.moveDown && delta < this.breakPoint / 4) return\n      if (!this.moveDown && delta > -this.breakPoint / 4) return\n\n      this.sendNotification(event)\n    },\n    sendNotification (event) {\n      // reset the calculated breakpoint\n      this.breakPoint = null\n\n      // and trigger the enter event\n      const item = this.item || this.$parent.item\n      this.notifyMouseEnter(this.group, event, this.listId, item)\n    }\n  }\n}\n</script>\n","export default {\n  methods: {\n    // ––––––––––––––––––––––––––––––––––––\n    // Getter methods\n    // ––––––––––––––––––––––––––––––––––––\n    getPathById (id, items = this.value) {\n      let path = []\n\n      items.every((item, i) => {\n        if (item[this.keyProp] === id) {\n          path.push(i)\n        } else if (item[this.childrenProp]) {\n          const childrenPath = this.getPathById(id, item[this.childrenProp])\n\n          if (childrenPath.length) {\n            path = path.concat(i).concat(childrenPath)\n          }\n        }\n\n        return path.length === 0\n      })\n\n      return path\n    },\n\n    getItemByPath (path, items = this.value) {\n      let item = null\n\n      path.forEach(index => {\n        const list = item && item[this.childrenProp] ? item[this.childrenProp] : items\n        item = list[index]\n      })\n\n      return item\n    },\n\n    getItemDepth (item) {\n      let level = 1\n\n      if (item[this.childrenProp] && item[this.childrenProp].length > 0) {\n        const childrenDepths = item[this.childrenProp].map(this.getItemDepth)\n        level += Math.max(...childrenDepths)\n      }\n\n      return level\n    },\n\n    getSplicePath (path, options = {}) {\n      const splicePath = {}\n      const numToRemove = options.numToRemove || 0\n      const itemsToInsert = options.itemsToInsert || []\n      const lastIndex = path.length - 1\n      let currentPath = splicePath\n\n      path.forEach((index, i) => {\n        if (i === lastIndex) {\n          currentPath.$splice = [[index, numToRemove, ...itemsToInsert]]\n        } else {\n          const nextPath = {}\n          currentPath[index] = { [options.childrenProp]: nextPath }\n          currentPath = nextPath\n        }\n      })\n\n      return splicePath\n    },\n\n    getRealNextPath (prevPath, nextPath) {\n      const ppLastIndex = prevPath.length - 1\n      const npLastIndex = nextPath.length - 1\n\n      if (prevPath.length < nextPath.length) {\n        // move into deep\n        let wasShifted = false\n\n        return nextPath.map((nextIndex, i) => {\n          if (wasShifted) {\n            return i === npLastIndex\n              ? nextIndex + 1\n              : nextIndex\n          }\n\n          if (typeof prevPath[i] !== 'number') {\n            return nextIndex\n          }\n\n          if (nextPath[i] > prevPath[i] && i === ppLastIndex) {\n            wasShifted = true\n            return nextIndex - 1\n          }\n\n          return nextIndex\n        })\n      } else if (prevPath.length === nextPath.length) {\n        // if move bottom + move to item with children => make it a first child instead of swap\n        if (nextPath[npLastIndex] > prevPath[npLastIndex]) {\n          const target = this.getItemByPath(nextPath)\n\n          if (target[this.childrenProp] && target[this.childrenProp].length && !this.isCollapsed(target)) {\n            return nextPath\n              .slice(0, -1)\n              .concat(nextPath[npLastIndex] - 1)\n              .concat(0)\n          }\n        }\n      }\n\n      return nextPath\n    }\n\n    // getItemOptions() {\n    //   const { renderItem, renderCollapseIcon, handler, childrenProp } = this.props;\n    //   const { dragItem } = this.state;\n\n    //   return {\n    //     dragItem,\n    //     childrenProp,\n    //     renderItem,\n    //     renderCollapseIcon,\n    //     handler,\n\n    //     onDragStart: this.onDragStart,\n    //     onMouseEnter: this.onMouseEnter,\n    //     isCollapsed: this.isCollapsed,\n    //     onToggleCollapse: this.onToggleCollapse\n    //   };\n    // }\n\n  }\n}\n","export default {\n  methods: {\n    hook (name, params) {\n      // If the hook has not been registered,\n      // we consider the hook as successful\n      if (!this.hooks[name]) return true\n\n      const result = this.hooks[name](params)\n\n      // If the hook does not return anything,\n      // we also consider it true\n      return result || result === undefined\n    }\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction stringifiable(obj) {\n    // Safely stringify Object.create(null)\n    /* istanbul ignore next */\n    return typeof obj === 'object' && !('toString' in obj) ?\n        Object.prototype.toString.call(obj).slice(8, -1) :\n        obj;\n}\nvar isProduction = typeof process === 'object' && process.env.NODE_ENV === 'production';\nfunction invariant(condition, message) {\n    if (!condition) {\n        /* istanbul ignore next */\n        if (isProduction) {\n            throw new Error('Invariant failed');\n        }\n        throw new Error(message());\n    }\n}\nexports.invariant = invariant;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar splice = Array.prototype.splice;\nvar toString = Object.prototype.toString;\nfunction type(obj) {\n    return toString.call(obj).slice(8, -1);\n}\nvar assign = Object.assign || /* istanbul ignore next */ (function (target, source) {\n    getAllKeys(source).forEach(function (key) {\n        if (hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n        }\n    });\n    return target;\n});\nvar getAllKeys = typeof Object.getOwnPropertySymbols === 'function'\n    ? function (obj) { return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)); }\n    /* istanbul ignore next */\n    : function (obj) { return Object.keys(obj); };\nfunction copy(object) {\n    return Array.isArray(object)\n        ? assign(object.constructor(object.length), object)\n        : (type(object) === 'Map')\n            ? new Map(object)\n            : (type(object) === 'Set')\n                ? new Set(object)\n                : (object && typeof object === 'object')\n                    ? assign(Object.create(Object.getPrototypeOf(object)), object)\n                    /* istanbul ignore next */\n                    : object;\n}\nvar Context = /** @class */ (function () {\n    function Context() {\n        this.commands = assign({}, defaultCommands);\n        this.update = this.update.bind(this);\n        // Deprecated: update.extend, update.isEquals and update.newContext\n        this.update.extend = this.extend = this.extend.bind(this);\n        this.update.isEquals = function (x, y) { return x === y; };\n        this.update.newContext = function () { return new Context().update; };\n    }\n    Object.defineProperty(Context.prototype, \"isEquals\", {\n        get: function () {\n            return this.update.isEquals;\n        },\n        set: function (value) {\n            this.update.isEquals = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Context.prototype.extend = function (directive, fn) {\n        this.commands[directive] = fn;\n    };\n    Context.prototype.update = function (object, $spec) {\n        var _this = this;\n        var spec = (typeof $spec === 'function') ? { $apply: $spec } : $spec;\n        if (!(Array.isArray(object) && Array.isArray(spec))) {\n            invariant(!Array.isArray(spec), function () { return \"update(): You provided an invalid spec to update(). The spec may \" +\n                \"not contain an array except as the value of $set, $push, $unshift, \" +\n                \"$splice or any custom command allowing an array value.\"; });\n        }\n        invariant(typeof spec === 'object' && spec !== null, function () { return \"update(): You provided an invalid spec to update(). The spec and \" +\n            \"every included key path must be plain objects containing one of the \" +\n            (\"following commands: \" + Object.keys(_this.commands).join(', ') + \".\"); });\n        var nextObject = object;\n        getAllKeys(spec).forEach(function (key) {\n            if (hasOwnProperty.call(_this.commands, key)) {\n                var objectWasNextObject = object === nextObject;\n                nextObject = _this.commands[key](spec[key], nextObject, spec, object);\n                if (objectWasNextObject && _this.isEquals(nextObject, object)) {\n                    nextObject = object;\n                }\n            }\n            else {\n                var nextValueForKey = type(object) === 'Map'\n                    ? _this.update(object.get(key), spec[key])\n                    : _this.update(object[key], spec[key]);\n                var nextObjectValue = type(nextObject) === 'Map'\n                    ? nextObject.get(key)\n                    : nextObject[key];\n                if (!_this.isEquals(nextValueForKey, nextObjectValue)\n                    || typeof nextValueForKey === 'undefined'\n                        && !hasOwnProperty.call(object, key)) {\n                    if (nextObject === object) {\n                        nextObject = copy(object);\n                    }\n                    if (type(nextObject) === 'Map') {\n                        nextObject.set(key, nextValueForKey);\n                    }\n                    else {\n                        nextObject[key] = nextValueForKey;\n                    }\n                }\n            }\n        });\n        return nextObject;\n    };\n    return Context;\n}());\nexports.Context = Context;\nvar defaultCommands = {\n    $push: function (value, nextObject, spec) {\n        invariantPushAndUnshift(nextObject, spec, '$push');\n        return value.length ? nextObject.concat(value) : nextObject;\n    },\n    $unshift: function (value, nextObject, spec) {\n        invariantPushAndUnshift(nextObject, spec, '$unshift');\n        return value.length ? value.concat(nextObject) : nextObject;\n    },\n    $splice: function (value, nextObject, spec, originalObject) {\n        invariantSplices(nextObject, spec);\n        value.forEach(function (args) {\n            invariantSplice(args);\n            if (nextObject === originalObject && args.length) {\n                nextObject = copy(originalObject);\n            }\n            splice.apply(nextObject, args);\n        });\n        return nextObject;\n    },\n    $set: function (value, _nextObject, spec) {\n        invariantSet(spec);\n        return value;\n    },\n    $toggle: function (targets, nextObject) {\n        invariantSpecArray(targets, '$toggle');\n        var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;\n        targets.forEach(function (target) {\n            nextObjectCopy[target] = !nextObject[target];\n        });\n        return nextObjectCopy;\n    },\n    $unset: function (value, nextObject, _spec, originalObject) {\n        invariantSpecArray(value, '$unset');\n        value.forEach(function (key) {\n            if (Object.hasOwnProperty.call(nextObject, key)) {\n                if (nextObject === originalObject) {\n                    nextObject = copy(originalObject);\n                }\n                delete nextObject[key];\n            }\n        });\n        return nextObject;\n    },\n    $add: function (values, nextObject, _spec, originalObject) {\n        invariantMapOrSet(nextObject, '$add');\n        invariantSpecArray(values, '$add');\n        if (type(nextObject) === 'Map') {\n            values.forEach(function (_a) {\n                var key = _a[0], value = _a[1];\n                if (nextObject === originalObject && nextObject.get(key) !== value) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject.set(key, value);\n            });\n        }\n        else {\n            values.forEach(function (value) {\n                if (nextObject === originalObject && !nextObject.has(value)) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject.add(value);\n            });\n        }\n        return nextObject;\n    },\n    $remove: function (value, nextObject, _spec, originalObject) {\n        invariantMapOrSet(nextObject, '$remove');\n        invariantSpecArray(value, '$remove');\n        value.forEach(function (key) {\n            if (nextObject === originalObject && nextObject.has(key)) {\n                nextObject = copy(originalObject);\n            }\n            nextObject.delete(key);\n        });\n        return nextObject;\n    },\n    $merge: function (value, nextObject, _spec, originalObject) {\n        invariantMerge(nextObject, value);\n        getAllKeys(value).forEach(function (key) {\n            if (value[key] !== nextObject[key]) {\n                if (nextObject === originalObject) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject[key] = value[key];\n            }\n        });\n        return nextObject;\n    },\n    $apply: function (value, original) {\n        invariantApply(value);\n        return value(original);\n    },\n};\nvar defaultContext = new Context();\nexports.isEquals = defaultContext.update.isEquals;\nexports.extend = defaultContext.extend;\nexports.default = defaultContext.update;\n// @ts-ignore\nexports.default.default = module.exports = assign(exports.default, exports);\n// invariants\nfunction invariantPushAndUnshift(value, spec, command) {\n    invariant(Array.isArray(value), function () { return \"update(): expected target of \" + stringifiable(command) + \" to be an array; got \" + stringifiable(value) + \".\"; });\n    invariantSpecArray(spec[command], command);\n}\nfunction invariantSpecArray(spec, command) {\n    invariant(Array.isArray(spec), function () { return \"update(): expected spec of \" + stringifiable(command) + \" to be an array; got \" + stringifiable(spec) + \". \" +\n        \"Did you forget to wrap your parameter in an array?\"; });\n}\nfunction invariantSplices(value, spec) {\n    invariant(Array.isArray(value), function () { return \"Expected $splice target to be an array; got \" + stringifiable(value); });\n    invariantSplice(spec.$splice);\n}\nfunction invariantSplice(value) {\n    invariant(Array.isArray(value), function () { return \"update(): expected spec of $splice to be an array of arrays; got \" + stringifiable(value) + \". \" +\n        \"Did you forget to wrap your parameters in an array?\"; });\n}\nfunction invariantApply(fn) {\n    invariant(typeof fn === 'function', function () { return \"update(): expected spec of $apply to be a function; got \" + stringifiable(fn) + \".\"; });\n}\nfunction invariantSet(spec) {\n    invariant(Object.keys(spec).length === 1, function () { return \"Cannot have more than one key in an object with $set\"; });\n}\nfunction invariantMerge(target, specValue) {\n    invariant(specValue && typeof specValue === 'object', function () { return \"update(): $merge expects a spec of type 'object'; got \" + stringifiable(specValue); });\n    invariant(target && typeof target === 'object', function () { return \"update(): $merge expects a target of type 'object'; got \" + stringifiable(target); });\n}\nfunction invariantMapOrSet(target, command) {\n    var typeOfTarget = type(target);\n    invariant(typeOfTarget === 'Map' || typeOfTarget === 'Set', function () { return \"update(): \" + stringifiable(command) + \" expects a target of type Set or Map; got \" + stringifiable(typeOfTarget); });\n}\n","export const closest = (target, selector) => {\n  return target.closest(selector)\n}\n\nexport const getOffsetRect = (elem) => {\n  var box = elem.getBoundingClientRect()\n\n  return { top: Math.round(box.top), left: Math.round(box.left) }\n}\n\nexport const getTransformProps = (x, y) => {\n  return {\n    transform: 'translate(' + x + 'px, ' + y + 'px)'\n  }\n}\n\nexport const listWithChildren = (list, childrenProp) => {\n  return list.map(item => {\n    return {\n      ...item,\n      [childrenProp]: item[childrenProp]\n        ? listWithChildren(item[childrenProp], childrenProp)\n        : []\n    }\n  })\n}\n","import VueNestable from './VueNestable.vue'\nimport VueNestableHandle from './VueNestableHandle.vue'\n\n// export named components\nexport {\n  VueNestable,\n  VueNestableHandle\n}\n\n// export vue component installer\nexport default {\n  install: function (Vue, options) {\n    Vue.component('VueNestable', VueNestable)\n    Vue.component('VueNestableHandle', VueNestableHandle)\n  }\n}\n"],"names":["store","methods","registerNestable","nestable","storeGroup","this","_getByGroup","group","onDragStartListeners","push","onDragStart","onMouseEnterListeners","onMouseEnter","onMouseMoveListeners","onMouseMove","notifyDragStart","event","item","listener","notifyMouseEnter","eventList","notifyMouseMove","dragItem","normalizeComponent","template","style","script","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","options","hook","render","staticRenderFns","_compiled","functional","_scopeId","context","$vnode","ssrContext","parent","__VUE_SSR_CONTEXT__","call","_registeredComponents","add","_ssrRegister","$root","$options","shadowRoot","originalRender","h","existing","beforeCreate","concat","getPathById","id","items","value","path","every","i","_this","keyProp","childrenProp","childrenPath","length","getItemByPath","forEach","index","list","_this2","getItemDepth","level","childrenDepths","map","Math","max","getSplicePath","splicePath","numToRemove","itemsToInsert","lastIndex","currentPath","$splice","nextPath","getRealNextPath","prevPath","ppLastIndex","npLastIndex","wasShifted","nextIndex","target","isCollapsed","slice","name","params","hooks","result","undefined","stringifiable","obj","Object","prototype","toString","defineProperty","exports","isProduction","process","invariant","condition","message","Error","hasOwnProperty","splice","Array","type","assign","source","getAllKeys","key","getOwnPropertySymbols","keys","copy","object","isArray","constructor","Map","Set","create","getPrototypeOf","Context","commands","defaultCommands","update","bind","extend","isEquals","x","y","newContext","get","set","enumerable","configurable","directive","fn","$spec","spec","$apply","join","nextObject","objectWasNextObject","nextValueForKey","nextObjectValue","$push","invariantPushAndUnshift","$unshift","originalObject","invariantSplice","invariantSplices","args","apply","$set","_nextObject","invariantSet","$toggle","targets","invariantSpecArray","nextObjectCopy","$unset","_spec","$add","values","invariantMapOrSet","_a","has","$remove","delete","$merge","specValue","original","defaultContext","command","typeOfTarget","default","module","listWithChildren","selector","closest","transform","elem","box","getBoundingClientRect","top","round","left","install","Vue","component","VueNestable","VueNestableHandle"],"mappings":"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"}